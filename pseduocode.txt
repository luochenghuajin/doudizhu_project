## Judger

function NewJudger(): Judger
    judger_instance <- create new Judger object
    // Judger can hold rule tables, rank orders, combination validators
    judger_instance.rank_order <- ["3","4","5","6","7","8","9","T","J","Q","K","A","2","B","R"]
    return judger_instance
    # Called by: Game.NewGame
end function
function IsGameOver(players: Sequence of Player): Boolean
    // Game over if any player has zero cards in hand
    for each p in players:
        if length(Call p.GetHand()) == 0:
            return true
        end if
    end for
    return false
    # Called by: Game.Run
end function
function GetWinner(players: Sequence of Player): Integer
    // Return the id of the first player with empty hand; if none, return -1
    for each p in players:
        if length(Call p.GetHand()) == 0:
            return Call p.GetId()
        end if
    end for
    return -1
    # Called by: Game.Run
end function
function CalculatePayoff(winner_id: Integer, landlord_id: Integer): Map of Integer→Integer
    payoff <- Map from Integer to Integer
    // initialize all to 0
    for id from 0 to 2:
        payoff[id] <- 0
    end for

    if winner_id == landlord_id:
        payoff[landlord_id] <- 1
        // peasants remain 0
    else:
        // Both peasants win
        for id from 0 to 2:
            if id != landlord_id:
                payoff[id] <- 1
            end if
        end for
    end if

    return payoff
    # Called by: Game.Run
end function

## Dealer

// Private helper function to create a standard 54-card deck
procedure CreateFullDeck(): Deck
    deck <- new empty Sequence of Card
    suits <- ["Spade", "Heart", "Club", "Diamond"]
    ranks <- ["3","4","5","6","7","8","9","T","J","Q","K","A","2"]

    for each suit in suits:
        for each rank in ranks:
            card <- create new Card with rank=rank, suit=suit
            Add card to deck
        end for
    end for

    // Add two jokers
    Add (create new Card with rank="B", suit=null) to deck    // Black Joker
    Add (create new Card with rank="R", suit=null) to deck    // Red Joker

    return deck
end procedure
// Private helper heuristic for ranking hands (simple, deterministic).
// Higher score implies stronger hand for bidding purpose.
procedure EvaluateHandHeuristic(hand_str: String): Integer
    // Count high ranks and jokers and pairs/triples
    score <- 0
    frequency <- Map from Char -> Integer
    for each ch in hand_str:
        if frequency contains ch:
            frequency[ch] <- frequency[ch] + 1
        else:
            frequency[ch] <- 1
        end if
    end for

    // Award points for powerful ranks
    for each (rank_char, count) in frequency:
        // Jokers are strongest
        if rank_char == "R":
            score <- score + 50 * count
        else if rank_char == "B":
            score <- score + 45 * count
        else if rank_char == "2":
            score <- score + 20 * count
        else if rank_char == "A":
            score <- score + 12 * count
        else if rank_char == "K":
            score <- score + 8 * count
        else if rank_char == "Q":
            score <- score + 6 * count
        else if rank_char == "J":
            score <- score + 5 * count
        else if rank_char == "T":
            score <- score + 4 * count
        else:
            score <- score + 1 * count
        end if

        // Award combos
        if count == 2:
            score <- score + 10   // pair
        else if count == 3:
            score <- score + 25   // triple
        else if count == 4:
            score <- score + 40   // bomb
        end if
    end for

    return score
end procedure

procedure NewDealer(): Dealer
    dealer_instance <- create new Dealer object
    dealer_instance.deck <- Call CreateFullDeck()
    return dealer_instance
end procedure
procedure ShuffleDeck(): Deck
    // Fisher-Yates shuffle on a copy of dealer's deck
    deck_to_shuffle <- copy(self.deck)
    n <- length(deck_to_shuffle)
    for i from n-1 down to 1:
        j <- random integer between 0 and i (inclusive)
        temp <- deck_to_shuffle[i]
        deck_to_shuffle[i] <- deck_to_shuffle[j]
        deck_to_shuffle[j] <- temp
    end for
    return deck_to_shuffle
end procedure

procedure Deal(deck: Deck): (Sequence of Hand, Hand)
    // Expect deck length == 54
    hands <- [new empty Hand, new empty Hand, new empty Hand]
    // Deal first 51 cards round-robin (17 each) and keep last 3 as seen_cards
    for i from 0 to 50:
        player_index <- i mod 3
        Add deck[i] to hands[player_index]
    end for

    seen_cards <- new empty Hand
    for i from 51 to 53:
        Add deck[i] to seen_cards
    end for

    return (hands, seen_cards)
end procedure
procedure DetermineLandlord(players: Sequence of Player): Integer
    // Heuristic: compute a simple hand-strength score for each player's current hand string
    // Use GetHandAsString accessor to avoid reaching into Player internals.
    best_score <- -infinity
    landlord_id <- 0

    for each player in players:
        hand_str <- Call player.GetHandAsString()
        score <- Call Dealer.EvaluateHandHeuristic(hand_str)
        if score > best_score:
            best_score <- score
            landlord_id <- Call player.GetId()
        end if
    end for

    // In tie cases the first max remains; ensure landlord_id is valid
    return landlord_id
end procedure


## Player

function CardsEqual(a: Card, b: Card): Boolean
    return (a.rank == b.rank) and ((a.suit == b.suit) or (a.suit == null) or (b.suit == null))
end function
procedure SortHand(player: Player): void
    // Simple stable sort by rank ordering then suit; maps rank to order index
    order_map <- Map{"3":0,"4":1,"5":2,"6":3,"7":4,"8":5,"9":6,"T":7,"J":8,"Q":9,"K":10,"A":11,"2":12,"B":13,"R":14}
    sort player.hand in-place by (order_map[card.rank], card.suit as string or "")
end procedure
function ParseActionStringToCards(player: Player, action_str: String): PlayAction
    // Convert a compact string action into actual Card objects picked from player's hand.
    // e.g., "K" -> choose one K from player's hand, "8222" -> choose one '8' and three '2's
    result <- new empty PlayAction
    if action_str == "pass":
        return result
    end if

    // Build a map from rank -> list of indices in hand
    rank_to_indices <- Map from Char -> Sequence of Integer
    for i from 0 to length(player.hand)-1:
        r <- player.hand[i].rank
        if not (rank_to_indices contains r):
            rank_to_indices[r] <- new empty Sequence of Integer
        end if
        Add i to rank_to_indices[r]
    end for

    // For each char in action_str, pop one available card of that rank
    for each ch in action_str:
        if (rank_to_indices contains ch) and length(rank_to_indices[ch]) > 0:
            idx <- Remove and return last element from rank_to_indices[ch]   // take one matching card
            Add copy(player.hand[idx]) to result
        else:
            // Fallback: if not available on hand, attempt to construct synthetic Card (shouldn't happen)
            Add create new Card with rank=ch, suit=null to result
        end if
    end for

    return result
end function
function GetHand(): Hand
    return copy(self.hand)
    # Called by: Judger
end function

function GetId(): Integer
    return self.id
    # Called by: Dealer.DetermineLandlord (inferred — for landlord selection logic)
end function

function GetRole(): String
    return self.role
    # Called by: Judger.CalculatePayoff (inferred — to distinguish landlord vs. peasant)
end function
function GetHandAsString(): String
    // Convert hand into compact string ordered by rank mapping used elsewhere.
    // Use rank characters only (suit omitted) for compactness like '345...R'
    rank_order <- ["3","4","5","6","7","8","9","T","J","Q","K","A","2","B","R"]
    bucket <- Map from Char -> Integer (all 0)
    for each card in self.hand:
        ch <- card.rank
        bucket[ch] <- bucket[ch] + 1
    end for

    result <- ""
    for each r in rank_order:
        count <- bucket[r]
        for i from 1 to count:
            result <- result + r
        end for
    end for
    return result
    # Called by: Game.BuildState
end function
function NewPlayer(id: Integer): Player
    player_instance <- create new Player object
    player_instance.id <- id
    player_instance.hand <- new empty Hand
    player_instance.role <- "peasant"   // default
    return player_instance
    # Called by: Game.NewGame
end function
function SetHand(hand: Hand): void
    self.hand <- copy(hand)
    # Called by: Game.Run
end function
function SetRole(role: String): void
    self.role <- role
    # Called by: Game.Run
end function
function AddCards(cards: Hand): void
    // Append cards to player's hand
    for each card in cards:
        Add card to self.hand
    end for
    // Keep deterministic ordering: sort hand by Rank ordering then suit (optional)
    Call Player.SortHand(self)
    # Called by: Game.Run
end function
function RemoveCards(cards: PlayAction): void
    // For each card in action, find and remove one matching card from hand
    for each played_card in cards:
        removed <- false
        for i from 0 to length(self.hand)-1:
            if Call Player.CardsEqual(self.hand[i], played_card):
                Remove item at index i from self.hand
                removed <- true
                break
            end if
        end for
        if not removed:
            // Defensive: if card not found, raise/print error and ignore (shouldn't happen)
            print("Warning: attempted to remove card not in hand for player", self.id)
        end if
    end for

    // Maintain order
    Call Player.SortHand(self)
    # Called by: Game.Run
end function
function SelectAction(state: Map): PlayAction
    // 职责：只从给定的合法动作列表中选择一个。
    legal_action_strings <- state["actions"]

    // 策略: 选择一个最长的非"pass"动作 (贪心策略)
    chosen_str <- "pass"
    max_len <- 0
    if not IsEmpty(legal_action_strings):
        // 如果列表为空(不应发生但做防御)，则默认pass
        chosen_str <- legal_action_strings[0] // 至少有一个动作
        for each act_str in legal_action_strings:
            if act_str != "pass" and length(act_str) > max_len:
                max_len <- length(act_str)
                chosen_str <- act_str
            end if
        end for
    end if
  
    // 如果没有找到可出的牌（除了pass），并且pass是合法选项，则选择pass
    if max_len == 0 and ("pass" in legal_action_strings):
        chosen_str <- "pass"
    end if
  
    if chosen_str == "pass":
        return new empty PlayAction
    else:
        return Call self.ParseActionStringToCards(chosen_str)
    end if
end function


## Round


function ActionToString(action: PlayAction): String
    s <- ""
    for each c in action:
        s <- s + c.rank
    end for
    return s
end function
function NewRound(players: Sequence of Player, judger: Judger): Round
    round_instance <- create new Round object
    round_instance.players <- players
    round_instance.judger <- judger
    round_instance.action_trace <- new empty Sequence of (Integer, String)
    round_instance.played_cards <- new empty Sequence of Card
    round_instance.last_non_pass_player <- null
    round_instance.consecutive_passes <- 0
    return round_instance
    # Called by: Game.NewGame
end function
function GetLastValidPlay(): (Integer, String)
    # Called by: Judger.GetLegalActions
    # Returns a tuple of (player_id, action_string) for the last non-pass play, or null if none.
  
    if self.last_non_pass_player is null:
        return null
  
    // Find the most recent action by the last non-pass player from the trace.
    for i from length(self.action_trace) - 1 down to 0:
        player_id, action_str <- self.action_trace[i]
        if player_id == self.last_non_pass_player:
            return (player_id, action_str)
        end if
    end for
  
    // Should not be reached if last_non_pass_player is not null, but as a fallback:
    return null
end function
function RecordAction(player_id: Integer, action: PlayAction): void
    // Record the action in trace and update played_cards and pass counters
    if length(action) == 0:
        // pass
        Add (player_id, "pass") to self.action_trace
        self.consecutive_passes <- self.consecutive_passes + 1
        // when pass, do not add cards to played_cards
    else:
        // convert played cards to string for trace (compact by ranks)
        action_str <- Call Round.ActionToString(action)
        Add (player_id, action_str) to self.action_trace
        for each c in action:
            Add c to self.played_cards
        end for
        // reset pass counter since someone played
        self.consecutive_passes <- 0
        self.last_non_pass_player <- player_id
    end if

    // If two consecutive passes after a play, the "pile" clears — but full game logic tracks only for turn order.
    return
    # Called by: Game.Run
end function
function GetNextPlayer(current_player_id: Integer): Integer
    // players are in sequence by their id order in round.players
    // find index of current_player_id
    n <- length(self.players)
    next_index <- -1
    for i from 0 to n-1:
        if Call self.players[i].GetId() == current_player_id:
            next_index <- (i + 1) mod n
            break
        end if
    end for
    if next_index == -1:
        // fallback to 0
        return Call self.players[0].GetId()
    end if
    return Call self.players[next_index].GetId()
    # Called by: Game.Run
end function
function GetActionTrace(): Sequence of (Integer, String)
    // Return a copy of the trace for safety
    return copy(self.action_trace)
    # Called by: Game.BuildState
end function
function GetAllPlayedCards(): Sequence of String
    // Return sorted list of played card ranks as strings (single-char per card)
    ranks_list <- new empty Sequence of String
    for each c in self.played_cards:
        Add c.rank to ranks_list
    end for
    sort ranks_list by self.judger.rank_order
    return ranks_list
    # Called by: Game.BuildState
end function


## ActionGenerator

# ============================================================
# Module Overview
# - Generates all legal action strings for a player, given the
#   player's hand (actual Card objects) and the current Round.
# - Returns actions as compact rank-only strings (e.g., "34567",
#   "QQ", "3334", "BR"). Order is canonicalized by rank order.
# - Always includes "pass".
# - Follows Dou Dizhu rules in the Appendix.
# ============================================================

# -----------------------------
# Construction
# -----------------------------
function NewActionGenerator(): ActionGenerator
    ag <- create new ActionGenerator object

    ag.RANK_ORDER <- ["3","4","5","6","7","8","9","T","J","Q","K","A","2","B","R"]
    # Faster lookups
    ag.RANK_TO_VAL <- Map from String to Integer
    for i from 0 to length(ag.RANK_ORDER)-1:
        ag.RANK_TO_VAL[ ag.RANK_ORDER[i] ] <- i
    end for

    # For "straight/pair-chain/airplane" the highest allowed rank is "A"
    ag.MAX_STRAIGHT_RANK <- "A"   # cannot include "2","B","R"
    ag.MIN_STRAIGHT_RANK <- "3"

    return ag
end function
function RankBefore(r: String): String or null
    idx <- self.RANK_TO_VAL[r]
    if idx <= 0: return null
    return self.RANK_ORDER[idx - 1]
end function
function RankAfter(r: String): String or null
    idx <- self.RANK_TO_VAL[r]
    if idx >= length(self.RANK_ORDER)-1: return null
    return self.RANK_ORDER[idx + 1]
end function
function IsRankInStraightRange(r: String): Boolean
    # Straight/PairChain/Airplane core allow only 3..A
    val <- self.RANK_TO_VAL[r]
    return (self.RANK_TO_VAL[self.MIN_STRAIGHT_RANK] <= val) and (val <= self.RANK_TO_VAL[self.MAX_STRAIGHT_RANK])
end function
function CountRanks(hand_cards: Hand): Map of Rank->Int
    m <- Map default 0
    for each c in hand_cards:
        m[c.rank] <- m[c.rank] + 1
    end for
    return m
end function
function CountRanksFromString(s: String): Map of Rank->Int
    m <- Map default 0
    for each ch in s:
        m[ch] <- m[ch] + 1
    end for
    return m
end function
function CloneCounts(m: Map Rank->Int): Map Rank->Int
    n <- Map default 0
    for each k, v in m:
        n[k] <- v
    end for
    return n
end function
function SubCounts(a: Map Rank->Int, b: Map Rank->Int): Map Rank->Int
    # returns (a - b), assumes a has enough
    n <- Call self.CloneCounts(a)
    for each k, v in b:
        n[k] <- n[k] - v
        if n[k] < 0: n[k] <- 0
    end for
    return n
end function
function MakeUseMap(ranks: Sequence of Rank, times: Integer): Map Rank->Int
    m <- Map default 0
    for each r in ranks:
        m[r] <- m[r] + times
    end for
    return m
end function
function CountTotal(m: Map Rank->Int): Integer
    s <- 0
    for each r, c in m:
        s <- s + c
    end for
    return s
end function
function NumberOfKeys(cnt: Map Rank->Int): Integer
    n <- 0
    for each r, c in cnt:
        n <- n + 1
    end for
    return n
end function
function AllSameCount(cnt: Map Rank->Int, value: Integer): Boolean
    if NumberOfKeys(cnt) == 0: return false
    for each r, c in cnt:
        if c != value: return false
    end for
    return true
end function
function AllCountsMax(cnt: Map Rank->Int, maxv: Integer): Boolean
    for each r, c in cnt:
        if c > maxv: return false
    end for
    return true
end function
function ContainsCount(cnt: Map Rank->Int, target: Integer): Boolean
    for each r, c in cnt:
        if c == target: return true
    end for
    return false
end function
function GetRankWithCount(cnt: Map Rank->Int, target: Integer): String
    for each r, c in cnt:
        if c == target: return r
    end for
    return null
end function
function SortRanks(ranks: Sequence of Rank): Sequence of Rank
    sort ranks ascending by self.RANK_TO_VAL[rank]
    return ranks
end function
function SortedRanks(cnt: Map Rank->Int): Sequence of Rank
    ranks <- new empty Sequence of String
    for each r, c in cnt:
        Append r to ranks
    end for
    return Call self.SortRanks(ranks)
end function
function IsConsecutive(ranks_sorted: Sequence of Rank): Boolean
    if length(ranks_sorted) <= 1: return true
    for i from 0 to length(ranks_sorted)-2:
        if self.RANK_TO_VAL[ranks_sorted[i+1]] != self.RANK_TO_VAL[ranks_sorted[i]] + 1:
            return false
        end if
    end for
    return true
end function
function AllWithinStraightRange(ranks_sorted: Sequence of Rank): Boolean
    for each r in ranks_sorted:
        if not Call self.IsRankInStraightRange(r):
            return false
        end if
    end for
    return true
end function
# ---- list builders for combinations ----
function ListSingleRanksFromCounts(cnt: Map Rank->Int): Sequence of Rank
    # Each rank appears as many times as multiplicity (so we can choose two different copies if available)
    out <- new empty Sequence of String
    for each r, c in cnt:
        for i from 1 to c:
            Append r to out
        end for
    end for
    # Keep stable order by rank value
    out <- Call self.SortRanks(out)
    return out
end function
function ListPairRanksFromCounts(cnt: Map Rank->Int): Sequence of Rank
    # Each rank appears floor(c/2) times; picking it once consumes 2 cards
    out <- new empty Sequence of String
    for each r, c in cnt:
        k <- floor(c / 2)
        for i from 1 to k:
            # Jokers cannot form pairs naturally; counts for "B"/"R" will be 0/1, so no entry added
            Append r to out
        end for
    end for
    out <- Call self.SortRanks(out)
    return out
end function
# pick k indices from array A (combinatorially, ascending index)
function CombinationsByIndex(A: Sequence, k: Integer): Sequence of Sequence of Integer
    result <- new empty Sequence of Sequence of Integer
    cur <- new empty Sequence of Integer
    procedure dfs(start: Integer, remain: Integer):
        if remain == 0:
            Append copy(cur) to result
            return
        end if
        for i from start to length(A) - remain:
            Append i to cur
            Call dfs(i + 1, remain - 1)
            Remove last element from cur
        end for
    end procedure
    if k <= length(A) and k >= 0:
        Call dfs(0, k)
    end if
    return result
end function
# ---- string utils for counts ----
function StringFromCounts(cnt: Map Rank->Int): String
    s <- ""
    ranks_sorted <- Call self.SortRanks(Call self.SortedRanks(cnt))
    for each r in ranks_sorted:
        for i from 1 to cnt[r]:
            s <- s + r
        end for
    end for
    return s
end function
# ============================================================
# Airplane helpers (cores + attachment validation)
# ============================================================
function FindAirplaneCores(counts: Map of Rank->Int): Sequence of Sequence of Rank
    cores <- new empty Sequence of Sequence of Rank
    # ranks eligible for core (>=3 and within straight range)
    elig <- new empty Sequence of String
    for each r, c in counts:
        if (c >= 3) and Call self.IsRankInStraightRange(r):
            Append r to elig
        end if
    end for
    elig <- Call self.SortRanks(elig)

    # consecutive blocks length >=2
    i <- 0
    while i < length(elig):
        j <- i
        while (j+1 < length(elig)) and (self.RANK_TO_VAL[elig[j+1]] == self.RANK_TO_VAL[elig[j]] + 1):
            j <- j + 1
        end while
        block_len <- j - i + 1
        if block_len >= 2:
            for L from 2 to block_len:
                for start from i to j - L + 1:
                    core <- new empty Sequence of String
                    for t from start to start + L - 1:
                        Append elig[t] to core
                    end for
                    Append core to cores
                end for
            end for
        end if
        i <- j + 1
    end while

    return cores
end function

function TryExtractAirplaneCore(cnt: Map Rank->Int): Map
    # Brute-force: try all possible cores (as IdentifyPatternFromString is called on already-fixed string)
    cores <- Call self.FindAirplaneCores(cnt)
    for each core_ranks in cores:
        # check if cnt has at least 3 of each core rank
        ok <- true
        for each r in core_ranks:
            if cnt[r] < 3:
                ok <- false
                break
            end if
        end for
        if ok:
            use <- Call self.MakeUseMap(core_ranks, 3)  # r -> 3
            return Map{"success":true, "core_ranks":core_ranks, "core_use":use}
        end if
    end for
    return Map{"success":false}
end function

# 返回字符串形式的 3×core_ranks（按顺序）
function RepeatRanks(core_ranks: Sequence of Rank, times: Integer): String
    s <- ""
    for each r in core_ranks:
        for k from 1 to times:
            s <- s + r
        end for
    end for
    return s
end function

# 统计是否满足：附件不包含火箭、整体不含炸弹、附件不会在核心两侧形成连续三张从而伪装小飞机
function IsValidAirplaneAttachmentCounts(core_ranks: Sequence of Rank, attach_cnt: Map Rank->Int, attach_type: String): Boolean
    # rule: if single attachments → 不允许双王
    if attach_type == "single":
        if (attach_cnt["B"] == 1) and (attach_cnt["R"] == 1):
            return false
        end if
    end if

    # 组合后的总计数 = core(每核3张) + attach_cnt
    total <- Map default 0
    for each r in core_ranks:
        total[r] <- total[r] + 3
    end for
    for each r, c in attach_cnt:
        total[r] <- total[r] + c
    end for

    # 不允许组合中出现炸弹（任何点数计数==4）
    for each r, c in total:
        if c == 4:
            return false
        end if
    end for

    # 边缘检查：附件不得在核心左/右边界点数上达到 >=3（会构成更大飞机）
    # 获取核心最小/最大点数
    min_r <- core_ranks[0]
    max_r <- core_ranks[length(core_ranks)-1]

    # 左边缘 = 前一位，必须在 [3..A] 范围内才检查
    left_edge <- Call self.RankBefore(min_r)
    if (left_edge != null) and Call self.IsRankInStraightRange(left_edge):
        if total[left_edge] >= 3:
            return false
        end if
    end if

    # 右边缘 = 后一位，必须在 [3..A] 范围内才检查
    right_edge <- Call self.RankAfter(max_r)
    if (right_edge != null) and Call self.IsRankInStraightRange(right_edge):
        if total[right_edge] >= 3:
            return false
        end if
    end if

    return true
end function
# 针对 IdentifyPatternFromString 调用的附件校验（字符串接口）
function IsValidAirplaneAttachmentString(core_str: String, attach_cnt: Map Rank->Int, attach_type: String): Boolean
    # derive core_ranks from core_str (every 3 contiguous chars per rank)
    core_rank_cnt <- Call self.CountRanksFromString(core_str)
    core_ranks <- Call self.SortedRanks(core_rank_cnt)
    return Call self.IsValidAirplaneAttachmentCounts(core_ranks, attach_cnt, attach_type)
end function
# ============================================================
# Pattern identification (from rank-string)
# Returns Map with fields, e.g.:
# kind: "solo"/"pair"/"trio"/"straight"/"pair_chain"/"airplane"/"airplane_single"/"airplane_pair"/"four_two_single"/"four_two_pair"/"bomb"/"rocket"/"invalid"
# main_value: Integer (value of main part's highest rank)
# length, pair_len, trio_len, core_count: auxiliary fields
# ============================================================
function IdentifyPatternFromString(action_str: String): Map
    info <- Map{"kind":"invalid","main_value":-1}

    if action_str == "" or action_str == "pass":
        return info
    end if

    # Count by rank
    cnt <- Call self.CountRanksFromString(action_str)

    # Rocket
    if (length(action_str) == 2) and (cnt["B"] == 1) and (cnt["R"] == 1):
        info["kind"] <- "rocket"
        info["main_value"] <- 999
        return info
    end if

    # Bomb
    if length(action_str) == 4:
        # exactly four of a kind
        for each rank, c in cnt:
            if c == 4:
                info["kind"] <- "bomb"
                info["main_value"] <- self.RANK_TO_VAL[rank]
                return info
            end if
        end for
    end if

    # Solo / Pair / Trio
    if length(action_str) == 1:
        r <- action_str[0]
        info["kind"] <- "solo"
        info["main_value"] <- self.RANK_TO_VAL[r]
        return info
    end if

    if length(action_str) == 2:
        # could be pair (not jokers, since "BR" already returned rocket)
        if Call self.AllSameCount(cnt, 2) and (NumberOfKeys(cnt) == 1):
            r <- AnyKey(cnt)
            info["kind"] <- "pair"
            info["main_value"] <- self.RANK_TO_VAL[r]
            return info
        end if
    end if

    if length(action_str) == 3:
        if Call self.AllSameCount(cnt, 3) and (NumberOfKeys(cnt) == 1):
            r <- AnyKey(cnt)
            info["kind"] <- "trio"
            info["main_value"] <- self.RANK_TO_VAL[r]
            info["core_count"] <- 1
            return info
        end if
    end if

    # Trio with single (4 cards): trio(3) + single(1), single rank must differ from trio rank
    if length(action_str) == 4:
        if Call self.ContainsCount(cnt, 3) and Call self.ContainsCount(cnt, 1) and (NumberOfKeys(cnt) == 2):
            trio_rank <- Call self.GetRankWithCount(cnt, 3)
            single_rank <- Call self.GetRankWithCount(cnt, 1)
            if trio_rank != single_rank:
                info["kind"] <- "trio_single"
                info["main_value"] <- self.RANK_TO_VAL[trio_rank]
                info["core_count"] <- 1
                return info
            end if
        end if
    end if

    # Trio with pair (5 cards): trio(3) + pair(2)
    if length(action_str) == 5:
        if Call self.ContainsCount(cnt, 3) and Call self.ContainsCount(cnt, 2) and (NumberOfKeys(cnt) == 2):
            trio_rank <- Call self.GetRankWithCount(cnt, 3)
            pair_rank <- Call self.GetRankWithCount(cnt, 2)
            if (trio_rank != pair_rank) and (pair_rank != "B") and (pair_rank != "R"):
                info["kind"] <- "trio_pair"
                info["main_value"] <- self.RANK_TO_VAL[trio_rank]
                info["core_count"] <- 1
                return info
            end if
        end if
    end if

    # Four with two singles (6 cards): four(4) + two singles (can be same or different); no rocket among these two 
    if length(action_str) == 6:
        if Call self.ContainsCount(cnt, 4):
            four_rank <- Call self.GetRankWithCount(cnt, 4)
            # Collect the remaining 2 cards
            rem_ranks <- new empty Sequence of String
            for each rank, c in cnt:
                if rank != four_rank:
                    for t from 1 to c:
                        Append rank to rem_ranks
                    end for
                end if
            end for
            # Must be exactly 2 remaining cards
            if length(rem_ranks) == 2:
                # Check they are not rocket (B + R)
                if not (("B" in rem_ranks) and ("R" in rem_ranks)):
                    info["kind"] <- "four_two_single"
                    info["main_value"] <- self.RANK_TO_VAL[four_rank]
                    return info
                end if
            end if
        end if
    end if


    # Four with two pairs (8 cards): four(4) + two pairs(2,2)
    if length(action_str) == 8:
        if Call self.ContainsCount(cnt, 4):
            four_rank <- Call self.GetRankWithCount(cnt, 4)
            # Check remaining are exactly two pairs (no jokers can make pair anyway)
            pairs_count <- 0
            ok <- true
            for each rank, c in cnt:
                if rank == four_rank: continue
                if c == 2:
                    pairs_count <- pairs_count + 1
                else:
                    ok <- false
                end if
            end for
            if ok and (pairs_count == 2):
                info["kind"] <- "four_two_pair"
                info["main_value"] <- self.RANK_TO_VAL[four_rank]
                return info
            end if
        end if
    end if

    # Straight: length>=5, all single, consecutive in [3..A]
    if (length(action_str) >= 5) and Call self.AllSameCount(cnt, 1):
        ranks_sorted <- Call self.SortedRanks(cnt)
        if Call self.AllWithinStraightRange(ranks_sorted) and Call self.IsConsecutive(ranks_sorted):
            # main value = highest rank in straight
            top <- ranks_sorted[length(ranks_sorted)-1]
            info["kind"] <- "straight"
            info["main_value"] <- self.RANK_TO_VAL[top]
            info["length"] <- length(action_str)
            return info
        end if
    end if

    # Pair Chain: total length >=6 and divisible by 2, all counts==2, consecutive in [3..A]
    if (length(action_str) >= 6) and (length(action_str) mod 2 == 0) and Call self.AllSameCount(cnt, 2):
        ranks_sorted <- Call self.SortedRanks(cnt)
        if Call self.AllWithinStraightRange(ranks_sorted) and Call self.IsConsecutive(ranks_sorted):
            top <- ranks_sorted[length(ranks_sorted)-1]
            info["kind"] <- "pair_chain"
            info["main_value"] <- self.RANK_TO_VAL[top]
            info["pair_len"] <- length(action_str) / 2
            return info
        end if
    end if

    # Airplane (pure): length divisible by 3, >= 6, all counts==3, consecutive in [3..A]
    if (length(action_str) >= 6) and (length(action_str) mod 3 == 0):
        if Call self.AllSameCount(cnt, 3):
            ranks_sorted <- Call self.SortedRanks(cnt)
            if Call self.AllWithinStraightRange(ranks_sorted) and Call self.IsConsecutive(ranks_sorted):
                top <- ranks_sorted[length(ranks_sorted)-1]
                info["kind"] <- "airplane"
                info["main_value"] <- self.RANK_TO_VAL[top]
                info["trio_len"] <- length(action_str) / 3
                info["core_count"] <- info["trio_len"]
                return info
            end if
        end if
    end if

    # Airplane with attachments:
    #   - with singles: total = 4*k, composed of k trios (consecutive) + k singles
    #   - with pairs  : total = 5*k, composed of k trios (consecutive) + k pairs
    # Identification strategy: try to extract a maximal consecutive trio-core.
    core <- Call self.TryExtractAirplaneCore(cnt)
    if core.success:
        k <- length(core.core_ranks)            # number of trios
        top <- core.core_ranks[k-1]
        remain <- Call self.SubCounts(cnt, core.core_use)  # remove exactly 3 of each core rank
        total_len <- length(action_str)

        # with singles: 4*k
        if total_len == 4 * k:
            # remaining must be k single cards; additionally must satisfy "no rocket inside", "no bomb in final"
            if Call self.CountTotal(remain) == k and Call self.AllCountsMax(remain, 1):
                # Validate attachments vs constraints (double-joker forbidden; no bombs in final; no adjacent-core extension by 3)
                airplane_cards_str <- Call self.RepeatRanks(core.core_ranks, 3)   # 3 of each in order
                if Call self.IsValidAirplaneAttachmentString(airplane_cards_str, remain, "single"):
                    info["kind"] <- "airplane_single"
                    info["main_value"] <- self.RANK_TO_VAL[top]
                    info["trio_len"] <- k
                    info["core_count"] <- k
                    return info
                end if
            end if
        end if

        # with pairs: 5*k
        if total_len == 5 * k:
            # remaining must be k pairs (counts all ==2)
            if Call self.CountTotal(remain) == 2 * k and Call self.AllSameCount(remain, 2):
                airplane_cards_str <- Call self.RepeatRanks(core.core_ranks, 3)
                if Call self.IsValidAirplaneAttachmentString(airplane_cards_str, remain, "pair"):
                    info["kind"] <- "airplane_pair"
                    info["main_value"] <- self.RANK_TO_VAL[top]
                    info["trio_len"] <- k
                    info["core_count"] <- k
                    return info
                end if
            end if
        end if
    end if

    return info
end function
function LexRankLess(a: String, b: String): Boolean
    # compare char by char using rank order map
    i <- 0
    while (i < length(a)) and (i < length(b)):
        va <- self.RANK_TO_VAL[a[i]]
        vb <- self.RANK_TO_VAL[b[i]]
        if va != vb:
            return va < vb
        end if
        i <- i + 1
    end while
    return length(a) < length(b)
end function
# ---- sorting and set-like canonicalization ----
function SortUnique(seq: Sequence of String): Sequence of String
    # Deduplicate first
    seen <- Set of String
    tmp <- new empty Sequence of String
    for each s in seq:
        if not (s in seen):
            Add s to seen
            Append s to tmp
        end if
    end for

    # Sort by:
    # 1) length ascending
    # 2) by main pattern value (if identifiable), otherwise lexicographic by rank order
    sort tmp with comparator CompareActions
    return tmp

    # local comparator
    function CompareActions(a: String, b: String): Boolean
        if length(a) != length(b):
            return length(a) < length(b)
        end if
        ia <- Call self.IdentifyPatternFromString(a)
        ib <- Call self.IdentifyPatternFromString(b)
        if (ia.kind != "invalid") and (ib.kind != "invalid"):
            if ia.main_value != ib.main_value:
                return ia.main_value < ib.main_value
            end if
            # tie-break by lexicographic in rank-order
            return Call self.LexRankLess(a, b)
        else:
            return Call self.LexRankLess(a, b)
        end if
    end function
end function
function FindSolos(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String
    counts <- Call self.CountRanks(hand_cards)
    for each r, c in counts:
        if c >= 1:
            Append r to result
        end if
    end for
    return Call self.SortUnique(result)
end function

function FindPairs(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String
    counts <- Call self.CountRanks(hand_cards)
    for each r, c in counts:
        if c >= 2 and r != "B" and r != "R":
            Append (r + r) to result
        end if
    end for
    return Call self.SortUnique(result)
end function

function FindTrios(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String
    counts <- Call self.CountRanks(hand_cards)
    for each r, c in counts:
        if c >= 3 and r != "B" and r != "R":
            Append (r + r + r) to result
        end if
    end for
    return Call self.SortUnique(result)
end function

# 三带一：附件单牌的点数不得与三张相同
function FindTrioWithSingle(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String
    counts <- Call self.CountRanks(hand_cards)

    for each r, c in counts:
        if c >= 3 and r != "B" and r != "R":
            # build remaining counts after taking trio rrr
            remain <- Call self.CloneCounts(counts)
            remain[r] <- remain[r] - 3

            # singles cannot be same rank as trio, and cannot be empty
            for each s_rank, s_cnt in remain:
                if s_cnt >= 1 and s_rank != r:
                    Append (r + r + r + s_rank) to result
                end if
            end for
        end if
    end for

    return Call self.SortUnique(result)
end function

function FindTrioWithPair(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String
    counts <- Call self.CountRanks(hand_cards)

    for each r, c in counts:
        if c >= 3 and r != "B" and r != "R":
            remain <- Call self.CloneCounts(counts)
            remain[r] <- remain[r] - 3
            for each p_rank, p_cnt in remain:
                if (p_cnt >= 2) and (p_rank != "B") and (p_rank != "R") and (p_rank != r):
                    Append (r + r + r + p_rank + p_rank) to result
                end if
            end for
        end if
    end for

    return Call self.SortUnique(result)
end function

function FindStraights(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String
    counts <- Call self.CountRanks(hand_cards)

    # collect ranks eligible for straight (>=1, 3..A)
    elig <- new empty Sequence of String
    for each r, c in counts:
        if (c >= 1) and Call self.IsRankInStraightRange(r):
            Append r to elig
        end if
    end for
    elig <- Call self.SortRanks(elig)  # ascending by RANK_TO_VAL

    # find all consecutive windows of length >= 5
    i <- 0
    while i < length(elig):
        j <- i
        while (j+1 < length(elig)) and (self.RANK_TO_VAL[elig[j+1]] == self.RANK_TO_VAL[elig[j]] + 1):
            j <- j + 1
        end while
        # elig[i..j] is a consecutive block
        block_len <- j - i + 1
        if block_len >= 5:
            # output all sub-windows of length >= 5
            for L from 5 to block_len:
                for start from i to j - L + 1:
                    s <- ""
                    for t from start to start + L - 1:
                        s <- s + elig[t]
                    end for
                    Append s to result
                end for
            end for
        end if
        i <- j + 1
    end while

    return Call self.SortUnique(result)
end function

function FindPairChains(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String
    counts <- Call self.CountRanks(hand_cards)

    # eligible ranks: count>=2 and in straight range
    elig <- new empty Sequence of String
    for each r, c in counts:
        if (c >= 2) and Call self.IsRankInStraightRange(r):
            Append r to elig
        end if
    end for
    elig <- Call self.SortRanks(elig)

    # consecutive blocks, each contributes 2 of that rank
    i <- 0
    while i < length(elig):
        j <- i
        while (j+1 < length(elig)) and (self.RANK_TO_VAL[elig[j+1]] == self.RANK_TO_VAL[elig[j]] + 1):
            j <- j + 1
        end while
        block_len <- j - i + 1
        if block_len >= 3:
            # sub-windows length >=3
            for L from 3 to block_len:
                for start from i to j - L + 1:
                    s <- ""
                    for t from start to start + L - 1:
                        s <- s + elig[t] + elig[t]
                    end for
                    Append s to result
                end for
            end for
        end if
        i <- j + 1
    end while

    return Call self.SortUnique(result)
end function

function FindAirplanes(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String
    counts <- Call self.CountRanks(hand_cards)

    # eligible ranks: count>=3 and in straight range
    elig <- new empty Sequence of String
    for each r, c in counts:
        if (c >= 3) and Call self.IsRankInStraightRange(r):
            Append r to elig
        end if
    end for
    elig <- Call self.SortRanks(elig)

    # find consecutive blocks of length >=2
    i <- 0
    while i < length(elig):
        j <- i
        while (j+1 < length(elig)) and (self.RANK_TO_VAL[elig[j+1]] == self.RANK_TO_VAL[elig[j]] + 1):
            j <- j + 1
        end while
        block_len <- j - i + 1
        if block_len >= 2:
            for L from 2 to block_len:
                for start from i to j - L + 1:
                    s <- ""
                    for t from start to start + L - 1:
                        s <- s + elig[t] + elig[t] + elig[t]
                    end for
                    Append s to result
                end for
            end for
        end if
        i <- j + 1
    end while

    return Call self.SortUnique(result)
end function

# 飞机带翅膀（整合了约束：不带双王（单牌）、最终无炸弹、附件不扩展成更大飞机）
function FindAirplanesWithAttachments(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String
    counts <- Call self.CountRanks(hand_cards)

    # 先找所有飞机核心
    cores <- Call self.FindAirplaneCores(counts)  # list of core_ranks (ascending) each

    for each core_ranks in cores:
        k <- length(core_ranks)
        # 构造核心牌串
        core_str <- Call self.RepeatRanks(core_ranks, 3)
        # 剩余牌计数
        remain <- Call self.SubCounts(counts, Call self.MakeUseMap(core_ranks, 3))

        # --- 带单牌：需要 k 个单牌 ---
        single_slots <- k
        single_candidates <- Call self.ListSingleRanksFromCounts(remain)  # ranks repeated by multiplicity
        # 组合从 single_candidates 中选 k 个不同“实例”（允许同点数多张，只要剩余中有多张）
        for each pick in Call self.CombinationsByIndex(single_candidates, single_slots):
            # 构造附件计数
            attach_cnt <- Map default 0
            for each idx in pick:
                r <- single_candidates[idx]
                attach_cnt[r] <- attach_cnt[r] + 1
            end for

            # 校验：不允许双王
            if (attach_cnt["B"] == 1) and (attach_cnt["R"] == 1):
                continue
            end if

            # 校验：最终无炸弹 && 不从大飞机拆出小飞机（边缘检查）
            if not Call self.IsValidAirplaneAttachmentCounts(core_ranks, attach_cnt, "single"):
                continue
            end if

            # 通过：拼接字符串
            attach_str <- Call self.StringFromCounts(attach_cnt)
            Append (core_str + attach_str) to result
        end for

        # --- 带对子：需要 k 个对子 ---
        pair_slots <- k
        pair_candidates <- Call self.ListPairRanksFromCounts(remain)  # rank appears floor(count/2) times
        for each pick in Call self.CombinationsByIndex(pair_candidates, pair_slots):
            # 构造附件计数（每个被选中的索引贡献2张）
            attach_cnt <- Map default 0
            for each idx in pick:
                r <- pair_candidates[idx]
                attach_cnt[r] <- attach_cnt[r] + 2
            end for

            # 校验：最终无炸弹 && 不从大飞机拆出小飞机（边缘检查）
            if not Call self.IsValidAirplaneAttachmentCounts(core_ranks, attach_cnt, "pair"):
                continue
            end if

            attach_str <- Call self.StringFromCounts(attach_cnt)
            Append (core_str + attach_str) to result
        end for
    end for

    return Call self.SortUnique(result)
end function

function FindFourWithTwo(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String
    counts <- Call self.CountRanks(hand_cards)

    for each r, c in counts:
        if c >= 4:
            # take four r as core
            core_str <- r + r + r + r
            remain <- Call self.CloneCounts(counts)
            remain[r] <- remain[r] - 4

            # --- two singles (distinct ranks; cannot be BR as rocket) ---
            singles <- Call self.ListSingleRanksFromCounts(remain)
            for each pick in Call self.CombinationsByIndex(singles, 2):
                rank1 <- singles[pick[0]]
                rank2 <- singles[pick[1]]
                if ((rank1 == "B" and rank2 == "R") or (rank1 == "R" and rank2 == "B")):
                    continue  # 不允许附件组成火箭
                end if
                s <- core_str + rank1 + rank2
                Append s to result
            end for

            # --- two pairs (distinct or same rank? 必须是两对 → 两个不同点数的对子) ---
            pairs <- Call self.ListPairRanksFromCounts(remain)
            for each pick in Call self.CombinationsByIndex(pairs, 2):
                rankA <- pairs[pick[0]]
                rankB <- pairs[pick[1]]
                if rankA == rankB:
                    continue
                # jokers不会形成对子；
                s <- core_str + rankA + rankA + rankB + rankB
                Append s to result
            end for
        end if
    end for

    return Call self.SortUnique(result)
end function

function FindBombs(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String
    counts <- Call self.CountRanks(hand_cards)
    for each r, c in counts:
        if c >= 4 and r != "B" and r != "R":
            Append (r + r + r + r) to result
        end if
    end for
    return Call self.SortUnique(result)
end function

function FilterHigherBombs(hand_cards: Hand, last_bomb_value: Integer): Sequence of String
    bombs <- Call self.FindBombs(hand_cards)
    out <- new empty Sequence of String
    for each b in bombs:
        r <- b[0]
        if self.RANK_TO_VAL[r] > last_bomb_value:
            Append b to out
        end if
    end for
    return Call self.SortUnique(out)
end function
function HasRocket(hand_cards: Hand): Boolean
    counts <- Call self.CountRanks(hand_cards)
    return (counts["B"] >= 1) and (counts["R"] >= 1)
end function
# ============================================================
# Follow case: generate same-pattern-stronger candidates
# Input: last_info (pattern attributes from IdentifyPatternFromString)
# ============================================================
function FindSamePatternStronger(hand_cards: Hand, last_info: Map): Sequence of String
    out <- new empty Sequence of String

    switch last_info.kind:

        case "solo":
            candidates <- Call self.FindSolos(hand_cards)
            for each s in candidates:
                val <- self.RANK_TO_VAL[ s[0] ]
                if val > last_info.main_value:
                    Append s to out
                end if
            end for

        case "pair":
            candidates <- Call self.FindPairs(hand_cards)
            for each s in candidates:
                val <- self.RANK_TO_VAL[ s[0] ]
                if val > last_info.main_value:
                    Append s to out
                end if
            end for

        case "trio":
            candidates <- Call self.FindTrios(hand_cards)
            for each s in candidates:
                trio_rank <- s[0]
                if self.RANK_TO_VAL[trio_rank] > last_info.main_value:
                    Append s to out
                end if
            end for

        case "trio_single":
            candidates <- Call self.FindTrioWithSingle(hand_cards)
            for each s in candidates:
                info <- Call self.IdentifyPatternFromString(s)
                if (info.kind == "trio_single") and
                   (info.core_count == last_info.core_count) and
                   (info.main_value > last_info.main_value):
                    Append s to out
                end if
            end for

        case "trio_pair":
            candidates <- Call self.FindTrioWithPair(hand_cards)
            for each s in candidates:
                info <- Call self.IdentifyPatternFromString(s)
                if (info.kind == "trio_pair") and
                   (info.core_count == last_info.core_count) and
                   (info.main_value > last_info.main_value):
                    Append s to out
                end if
            end for

        case "straight":
            candidates <- Call self.FindStraights(hand_cards)
            for each s in candidates:
                info <- Call self.IdentifyPatternFromString(s)
                if (info.kind == "straight") and
                   (info.length == last_info.length) and
                   (info.main_value > last_info.main_value):
                    Append s to out
                end if
            end for

        case "pair_chain":
            candidates <- Call self.FindPairChains(hand_cards)
            for each s in candidates:
                info <- Call self.IdentifyPatternFromString(s)
                if (info.kind == "pair_chain") and
                   (info.pair_len == last_info.pair_len) and
                   (info.main_value > last_info.main_value):
                    Append s to out
                end if
            end for

        case "airplane":
            candidates <- Call self.FindAirplanes(hand_cards)
            for each s in candidates:
                info <- Call self.IdentifyPatternFromString(s)
                if (info.kind == "airplane") and
                   (info.trio_len == last_info.trio_len) and
                   (info.main_value > last_info.main_value):
                    Append s to out
                end if
            end for

        case "airplane_single":
            candidates <- Call self.FindAirplanesWithAttachments(hand_cards)
            for each s in candidates:
                info <- Call self.IdentifyPatternFromString(s)
                if (info.kind == "airplane_single") and
                   (info.trio_len == last_info.trio_len) and
                   (info.main_value > last_info.main_value):
                    Append s to out
                end if
            end for

        case "airplane_pair":
            candidates <- Call self.FindAirplanesWithAttachments(hand_cards)
            for each s in candidates:
                info <- Call self.IdentifyPatternFromString(s)
                if (info.kind == "airplane_pair") and
                   (info.trio_len == last_info.trio_len) and
                   (info.main_value > last_info.main_value):
                    Append s to out
                end if
            end for

        case "four_two_single":
            candidates <- Call self.FindFourWithTwo(hand_cards)   # both forms returned; filter in identify
            for each s in candidates:
                info <- Call self.IdentifyPatternFromString(s)
                if (info.kind == "four_two_single") and
                   (info.main_value > last_info.main_value):
                    Append s to out
                end if
            end for

        case "four_two_pair":
            candidates <- Call self.FindFourWithTwo(hand_cards)
            for each s in candidates:
                info <- Call self.IdentifyPatternFromString(s)
                if (info.kind == "four_two_pair") and
                   (info.main_value > last_info.main_value):
                    Append s to out
                end if
            end for

        case "bomb":
            # handled outside by FilterHigherBombs
            pass

        default:
            # do nothing
            pass
    end switch

    return Call self.SortUnique(out)
end function
# ============================================================
# High-level generation (Free play)
# ============================================================
function GenerateAllPatterns(hand_cards: Hand): Sequence of String
    result <- new empty Sequence of String

    solos <- Call self.FindSolos(hand_cards)
    for each s in solos: Append s to result

    pairs <- Call self.FindPairs(hand_cards)
    for each s in pairs: Append s to result

    trios <- Call self.FindTrios(hand_cards)
    for each s in trios: Append s to result

    trio_single <- Call self.FindTrioWithSingle(hand_cards)
    for each s in trio_single: Append s to result

    trio_pair <- Call self.FindTrioWithPair(hand_cards)
    for each s in trio_pair: Append s to result

    straights <- Call self.FindStraights(hand_cards)
    for each s in straights: Append s to result

    pair_chains <- Call self.FindPairChains(hand_cards)
    for each s in pair_chains: Append s to result

    airplanes <- Call self.FindAirplanes(hand_cards)
    for each s in airplanes: Append s to result

    airplane_wings <- Call self.FindAirplanesWithAttachments(hand_cards)
    for each s in airplane_wings: Append s to result

    four_two <- Call self.FindFourWithTwo(hand_cards)
    for each s in four_two: Append s to result

    bombs <- Call self.FindBombs(hand_cards)
    for each s in bombs: Append s to result

    if Call self.HasRocket(hand_cards):
        Append "BR" to result
    end if

    return Call self.SortUnique(result)
end function
# ============================================================
# Public API
# ============================================================
function GetLegalActions(player: Player, round_context: Round): Sequence of String
    actions <- new empty Sequence of String
    hand_cards <- Call player.GetHand()

    # Retrieve last non-pass play
    last <- Call round_context.GetLastValidPlay()  # (player_id, action_str) or null

    if (last is null) or (last[0] == Call player.GetId()):
        # Free play: generate everything
        all_patterns <- Call self.GenerateAllPatterns(hand_cards)
        for each s in all_patterns:
            Append s to actions
        end for
        return Call self.SortUnique(actions)
    end if

    # Follow case
    Append "pass" to actions
    last_str <- last[1]
    last_info <- Call self.IdentifyPatternFromString(last_str)

    # If last was invalid (shouldn't happen), treat as free play (minus duplication)
    if last_info.kind == "invalid":
        all_patterns <- Call self.GenerateAllPatterns(hand_cards)
        for each s in all_patterns:
            Append s to actions
        end for
        return Call self.SortUnique(actions)
    end if

    # If last was rocket, nothing can beat it; only "pass"
    if last_info.kind == "rocket":
        return Call self.SortUnique(actions)
    end if

    # 1) Same pattern but stronger (same size & type)
    stronger <- Call self.FindSamePatternStronger(hand_cards, last_info)
    for each s in stronger:
        Append s to actions
    end for

    # 2) Any bomb beats non-bomb
    if last_info.kind != "bomb":
        bombs <- Call self.FindBombs(hand_cards)
        for each b in bombs:
            Append b to actions
        end for
    else:
        # last is bomb → only higher bomb allowed
        higher_bombs <- Call self.FilterHigherBombs(hand_cards, last_info.main_value)
        for each b in higher_bombs:
            Append b to actions
        end for
    end if

    # 3) Rocket always allowed if present
    if Call self.HasRocket(hand_cards):
        Append "BR" to actions
    end if

    return Call self.SortUnique(actions)
end function




## Game

function GetOthersHandAsString(exclude_player_id: Integer): String
    // Combine other two players' hands into a single compact string
    combined <- ""
    for each p in self.players:
        if Call p.GetId() == exclude_player_id:
            continue
        end if
        combined <- combined + Call p.GetHandAsString()
    end for
    // sort combined by rank order for deterministic representation
    // Use judger's rank order if available
    order_map <- Map{"3":0,"4":1,"5":2,"6":3,"7":4,"8":5,"9":6,"T":7,"J":8,"Q":9,"K":10,"A":11,"2":12,"B":13,"R":14}
    chars <- Sequence of Char from combined
    sort chars by order_map[char]
    result <- ""
    for each ch in chars:
        result <- result + ch
    end for
    return result
    # Called by: Game.BuildState
end function
function BuildState(current_player_id: Integer, landlord_id: Integer, seen_cards: Hand, legal_actions: Sequence of String): Map
    current_hand <- Call self.players[current_player_id].GetHandAsString()
    others_hand <- Call self.GetOthersHandAsString(current_player_id)
    trace <- Call self.round.GetActionTrace()
    played_cards <- Call self.round.GetAllPlayedCards()

    // Convert seen_cards hand to compact string
    seen_str <- ""
    for each c in seen_cards:
        seen_str <- seen_str + c.rank
    end for

    state <- Map{
        "self": current_player_id,
        "current_hand": current_hand,
        "others_hand": others_hand,
        "actions": legal_actions,
        "trace": trace,
        "landlord": landlord_id,
        "seen_cards": seen_str,
        "played_cards": played_cards
    }
    return state
    # Called by: Game.Run
end function
function DisplayResults(winner_id: Integer, payoff: Map of Integer→Integer): void
    if winner_id == -1:
        print("No winner determined.")
    else:
        print("Game winner: Player", winner_id)
    end if
    print("Payoff:")
    for id from 0 to 2:
        print(" Player", id, ":", payoff[id])
    end for

    // Optionally print final hands and trace for debugging
    print("Final hands (post-play):")
    for each p in self.players:
        print(" Player", Call p.GetId(), "role=", Call p.GetRole(), "hand=", Call p.GetHandAsString())
    end for
    print("Action trace:")
    trace <- Call self.round.GetActionTrace()
    for each entry in trace:
        print(entry)
    end for
    return
    # Called by: Game.Run
end function
function NewGame(): Game
    game <- create new Game object
    // create players
    game.players <- [ Call Player.NewPlayer(0),
                      Call Player.NewPlayer(1),
                      Call Player.NewPlayer(2) ]
    game.dealer <- Call Dealer.NewDealer()
    game.judger <- Call Judger.NewJudger()
    game.round <- Call Round.NewRound(game.players, game.judger)
    game.seen_cards <- new empty Hand
    game.action_generator <- Call ActionGenerator.NewActionGenerator()
    game.landlord_id <- null
    return game
    # Called by: Main
end function
function Run(): void
    // Step 1: Setup deck and deal
    deck <- Call self.dealer.ShuffleDeck()
    (hands, seen_cards) <- Call self.dealer.Deal(deck)
    self.seen_cards <- seen_cards

    // Step 2: Assign hands to players
    for i from 0 to 2:
        Call self.players[i].SetHand(hands[i])
    end for

    // Step 3: Determine landlord heuristically and give seen cards
    landlord_id <- Call self.dealer.DetermineLandlord(self.players)
    self.landlord_id <- landlord_id

    // Add seen cards to landlord's hand
    for i from 0 to 2:
        if Call self.players[i].GetId() == landlord_id:
            Call self.players[i].AddCards(seen_cards)
            Call self.players[i].SetRole("landlord")
        else:
            Call self.players[i].SetRole("peasant")
        end if
    end for

    // Step 4: Game loop begins with landlord
    current_player_id <- landlord_id

    // Safety cap to prevent infinite loops in buggy implementations
    turn_count <- 0
    max_turns <- 163

    while not Call self.judger.IsGameOver(self.players):
        if turn_count >= max_turns:
            print("Reached max turns, aborting game loop.")
            break
        end if
        current_player <- self.players[current_player_id]
        legal_actions <- Call self.action_generator.GetLegalActions(current_player, self.round)
        // Build state for the current player
        state <- Call self.BuildState(current_player_id, landlord_id, seen_cards, legal_actions)

        // Get player's chosen action
        action <- Call self.players[current_player_id].SelectAction(state)

        if action is empty:
            action_as_string <- "pass"
        else:
            action_as_string <- Call self.round.ActionToString(action)
        end if

        is_legal <- false
        for each legal_action_str in state["actions"]:
            if action_as_string == legal_action_str:
                is_legal <- true
                break
            end if
        end for

        if not is_legal:
            // Fallback for an invalid action returned by the Player module.
            print("Warning: Player", current_player_id, "returned an illegal action. Choosing a valid fallback.")
  
            fallback_action_str <- state["actions"][0]
  
            // We need to convert the fallback string back to a PlayAction object for processing
            action <- Call Player.ParseActionStringToCards(self.players[current_player_id], fallback_action_str) 
        end if

        // Apply the action to the round and the player
        Call self.round.RecordAction(current_player_id, action)
        Call self.players[current_player_id].RemoveCards(action)

        // Check for winner immediately
        if Call self.judger.IsGameOver(self.players):
            break
        end if

        // Determine next player
        current_player_id <- Call self.round.GetNextPlayer(current_player_id)
        turn_count <- turn_count + 1
    end while

    // Step 5: Calculate payoff and display results
    winner_id <- Call self.judger.GetWinner(self.players)
    payoff <- Call self.judger.CalculatePayoff(winner_id, self.landlord_id)
    Call self.DisplayResults(winner_id, payoff)
    return
    # Called by: Main
end function